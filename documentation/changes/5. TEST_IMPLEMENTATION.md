# Test Implementation Guide

## Overview

This guide provides comprehensive instructions for implementing tests in the DEC_L project. We use Jest as our testing framework with TypeScript support, and follow consistent patterns across all test suites.

**Last Updated:** December 11, 2025 - 7:00 PM  
**Current Test Coverage:** 58.34% overall (144 tests passing)

---

## Current Implementation Status (December 11, 2025)

### Overall Metrics

**Total Tests:** 144 passing  
**Overall Coverage:** 58.34%  
**Coverage Target:** 80%  
**Gap:** 21.66% below target

### Service Test Results

| Service         | Test File                | Tests | Coverage | Status        |
| --------------- | ------------------------ | ----- | -------- | ------------- |
| AuthService     | auth.service.test.ts     | 19    | 100%     | ‚úÖ Excellent  |
| UserService     | user.service.test.ts     | 31    | 98.71%   | ‚úÖ Excellent  |
| PostService     | post.service.test.ts     | 47    | 51.92%   | ‚ö†Ô∏è Needs Work |
| CategoryService | category.service.test.ts | 21    | 100%     | ‚úÖ Excellent  |
| PaymentService  | payment.service.test.ts  | 26    | 100%     | ‚úÖ Excellent  |

### Utility Test Results

| Utility        | Test File             | Tests | Coverage | Status         |
| -------------- | --------------------- | ----- | -------- | -------------- |
| PasswordUtil   | password.util.test.ts | 13    | 100%     | ‚úÖ Excellent   |
| JwtUtil        | jwt.util.test.ts      | 14    | 100%     | ‚úÖ Excellent   |
| ValidationUtil | ‚ùå MISSING            | 0     | 68.75%   | ‚ö†Ô∏è Needs Tests |

### Coverage Analysis

**Meeting 80% Threshold:** 4 out of 5 services (80%)

- ‚úÖ AuthService: 100% (20% above threshold)
- ‚úÖ UserService: 98.71% (18.71% above threshold)
- ‚ùå PostService: 51.92% (28.08% BELOW threshold) üî¥
- ‚úÖ CategoryService: 100% (20% above threshold)
- ‚úÖ PaymentService: 100% (20% above threshold)

**Critical Gaps:**

1. **PostService:** Needs 28.08% more coverage - requires ~20-25 additional tests
2. **ValidationUtil:** No dedicated test file - needs comprehensive Joi schema tests
3. **Integration Tests:** None exist - need end-to-end API tests

### Priority Test Improvements

**Priority 1 - PostService Coverage** (Estimated: 6-8 hours)

- Add tests for error handling paths
- Test edge cases (empty results, invalid IDs)
- Test authorization checks
- Test image upload scenarios
- Test scheduling logic

**Priority 2 - ValidationUtil Tests** (Estimated: 4-6 hours)

- Create validation.util.test.ts
- Test all Joi schemas
- Test validation error messages
- Test edge cases and boundary conditions

**Priority 3 - Integration Tests** (Estimated: 12-16 hours)

- End-to-end API tests using supertest
- Database integration tests
- OAuth flow integration tests
- Payment workflow tests

---

## Table of Contents

1. [Testing Stack](#testing-stack)
2. [Project Structure](#project-structure)
3. [Test Setup](#test-setup)
4. [Writing Tests](#writing-tests)
5. [Mock Patterns](#mock-patterns)
6. [Test Data Helpers](#test-data-helpers)
7. [Coverage Requirements](#coverage-requirements)
8. [Running Tests](#running-tests)
9. [Best Practices](#best-practices)
10. [Examples](#examples)

---

## Testing Stack

### Dependencies

```json
{
  "devDependencies": {
    "@jest/globals": "^29.7.0",
    "@types/jest": "^29.5.11",
    "jest": "^29.7.0",
    "ts-jest": "^29.1.1",
    "@faker-js/faker": "^8.3.1",
    "supertest": "^6.3.3"
  }
}
```

### Key Technologies

- **Jest 29.7.0** - Testing framework
- **ts-jest 29.1.1** - TypeScript support for Jest
- **@jest/globals** - Type-safe Jest globals (describe, it, expect, etc.)
- **@faker-js/faker** - Generate realistic mock data
- **supertest** - HTTP integration testing (future use)

---

## Project Structure

```
src/
‚îú‚îÄ‚îÄ __tests__/
‚îÇ   ‚îú‚îÄ‚îÄ setup.ts                    # Global test configuration
‚îÇ   ‚îú‚îÄ‚îÄ helpers/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ test-data.ts           # Mock data generators
‚îÇ   ‚îî‚îÄ‚îÄ unit/
‚îÇ       ‚îú‚îÄ‚îÄ utils/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ password.util.test.ts
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ jwt.util.test.ts
‚îÇ       ‚îî‚îÄ‚îÄ services/
‚îÇ           ‚îú‚îÄ‚îÄ auth.service.test.ts
‚îÇ           ‚îú‚îÄ‚îÄ user.service.test.ts
‚îÇ           ‚îú‚îÄ‚îÄ post.service.test.ts
‚îÇ           ‚îú‚îÄ‚îÄ category.service.test.ts
‚îÇ           ‚îî‚îÄ‚îÄ payment.service.test.ts
‚îú‚îÄ‚îÄ services/
‚îú‚îÄ‚îÄ utils/
‚îî‚îÄ‚îÄ dal/
```

---

## Test Setup

### Jest Configuration (`jest.config.js`)

```javascript
module.exports = {
  preset: "ts-jest",
  testEnvironment: "node",
  roots: ["<rootDir>/src"],
  testMatch: ["**/__tests__/**/*.test.ts"],
  collectCoverageFrom: [
    "src/**/*.{ts,tsx}",
    "!src/**/*.d.ts",
    "!src/__tests__/**",
  ],
  coverageThreshold: {
    global: {
      statements: 80,
      branches: 80,
      functions: 80,
      lines: 80,
    },
  },
  setupFilesAfterEnv: ["<rootDir>/src/__tests__/setup.ts"],
};
```

### Global Setup (`src/__tests__/setup.ts`)

```typescript
import { beforeAll, afterAll, beforeEach, afterEach } from "@jest/globals";

beforeAll(() => {
  console.log("Test suite starting...");
});

afterAll(() => {
  console.log("Test suite completed.");
});

beforeEach(() => {
  // Reset all mocks before each test
  jest.clearAllMocks();
});

afterEach(() => {
  // Clean up after each test
  jest.restoreAllMocks();
});
```

---

## Writing Tests

### Test File Structure

Every test file should follow this structure:

```typescript
import { describe, it, expect, beforeEach, jest } from "@jest/globals";
import { ServiceName } from "../../../services/service-name.service";
import { repositoryName } from "../../../dal/repositories";
import { createMockUser, createMockPost } from "../../helpers/test-data";
import { ErrorCode } from "../../../types/common/api-response.types";

type MockedFunction = jest.MockedFunction<any>;

// Mock repositories
jest.mock("../../../dal/repositories", () => ({
  repositoryName: {
    methodOne: jest.fn<any>(),
    methodTwo: jest.fn<any>(),
  },
  // Other repositories as empty objects to avoid errors
  otherRepository: {},
}));

describe("ServiceName", () => {
  let service: ServiceName;
  let mockData: any;

  beforeEach(() => {
    jest.clearAllMocks();
    service = new ServiceName();
    mockData = createMockUser();
  });

  describe("methodName", () => {
    it("should handle success case", async () => {
      // Arrange
      const input = {
        /* test input */
      };
      (repositoryName.methodOne as MockedFunction).mockResolvedValue(mockData);

      // Act
      const result = await service.methodName(input);

      // Assert
      expect(result.success).toBe(true);
      expect(result.data).toBeDefined();
      expect(repositoryName.methodOne).toHaveBeenCalledWith(input);
    });

    it("should handle error case", async () => {
      // Arrange
      (repositoryName.methodOne as MockedFunction).mockResolvedValue(null);

      // Act
      const result = await service.methodName(999);

      // Assert
      expect(result.success).toBe(false);
      expect(result.error?.code).toBe(ErrorCode.RESOURCE_NOT_FOUND);
      expect(result.error?.statusCode).toBe(404);
    });
  });
});
```

### AAA Pattern (Arrange-Act-Assert)

All tests should follow the AAA pattern:

```typescript
it("should create user successfully", async () => {
  // Arrange - Set up test data and mocks
  const userData = { email: "test@example.com", password: "Test123!" };
  (userRepository.create as MockedFunction).mockResolvedValue(mockUser);

  // Act - Execute the function being tested
  const result = await authService.register(userData);

  // Assert - Verify the results
  expect(result.success).toBe(true);
  expect(result.data?.email).toBe(userData.email);
  expect(userRepository.create).toHaveBeenCalledTimes(1);
});
```

---

## Mock Patterns

### 1. Mocking Repositories

```typescript
jest.mock("../../../dal/repositories", () => ({
  userRepository: {
    findById: jest.fn<any>(),
    findByEmail: jest.fn<any>(),
    create: jest.fn<any>(),
    update: jest.fn<any>(),
  },
  // Include other repositories as empty objects
  postRepository: {},
  categoryRepository: {},
}));
```

### 2. Setting Mock Return Values

```typescript
// Mock successful response
(userRepository.findById as MockedFunction).mockResolvedValue(mockUser);

// Mock null/not found
(userRepository.findById as MockedFunction).mockResolvedValue(null);

// Mock error
(userRepository.create as MockedFunction).mockRejectedValue(
  new Error("Database error")
);

// Mock different values for multiple calls
(repository.method as MockedFunction)
  .mockResolvedValueOnce(firstValue)
  .mockResolvedValueOnce(secondValue);
```

### 3. Type-Safe Mocking

Always use `MockedFunction` type for proper TypeScript support:

```typescript
type MockedFunction = jest.MockedFunction<any>;

// Usage
(repository.method as MockedFunction).mockResolvedValue(data);
```

### 4. Verifying Mock Calls

```typescript
// Verify method was called
expect(repository.method).toHaveBeenCalled();

// Verify call count
expect(repository.method).toHaveBeenCalledTimes(1);

// Verify arguments
expect(repository.method).toHaveBeenCalledWith(expectedArg1, expectedArg2);

// Verify partial object matching
expect(repository.method).toHaveBeenCalledWith(
  expect.objectContaining({
    email: "test@example.com",
  })
);
```

---

## Test Data Helpers

### Creating Mock Data Generators

Located in `src/__tests__/helpers/test-data.ts`:

```typescript
import { faker } from "@faker-js/faker";

export const createMockUser = (overrides: any = {}) => ({
  id: faker.number.int({ min: 1, max: 1000 }),
  email: faker.internet.email(),
  phoneNumber: faker.phone.number(),
  fullName: faker.person.fullName(),
  passwordHash: "$2b$12$mockHashedPassword",
  profilePictureUrl: faker.image.avatar(),
  location: faker.location.city(),
  isActive: true,
  isAdmin: false,
  createdAt: faker.date.past(),
  updatedAt: faker.date.recent(),
  ...overrides,
});

export const createMockPost = (
  userId: number,
  categoryId: number,
  overrides: any = {}
) => ({
  id: faker.number.int({ min: 1, max: 1000 }),
  userId,
  categoryId,
  title: faker.commerce.productName(),
  description: faker.commerce.productDescription(),
  price: parseFloat(faker.commerce.price()),
  location: faker.location.city(),
  status: "Draft",
  createdAt: faker.date.past(),
  ...overrides,
});

export const createMockCategory = (overrides: any = {}) => ({
  id: faker.number.int({ min: 1, max: 100 }),
  name: faker.commerce.department(),
  description: faker.commerce.productDescription(),
  createdAt: faker.date.past(),
  ...overrides,
});

export const createMockPayment = (
  userId: number,
  postId: number,
  overrides: any = {}
) => ({
  id: faker.number.int({ min: 1, max: 1000 }),
  userId,
  postId,
  amount: parseFloat(faker.commerce.price()),
  currency: "UGX",
  paymentMethod: "MobileMoney",
  status: "Pending",
  createdAt: faker.date.recent(),
  ...overrides,
});
```

### Using Test Helpers

```typescript
import { createMockUser, createMockPost } from "../../helpers/test-data";

// Create with defaults
const user = createMockUser();

// Override specific fields
const adminUser = createMockUser({ isAdmin: true });

// Create related data
const post = createMockPost(user.id, 1);

// Override nested properties
const paidPost = createMockPost(user.id, 1, {
  status: "Active",
  price: 50000,
});
```

---

## Coverage Requirements

### Thresholds

All code must meet these coverage requirements:

- **Statements:** 80%
- **Branches:** 80%
- **Functions:** 80%
- **Lines:** 80%

### What to Test

#### ‚úÖ Always Test

1. **Success paths** - Happy path scenarios
2. **Error handling** - All error cases
3. **Edge cases** - Boundary conditions
4. **Validation** - Input validation failures
5. **Business logic** - All conditional logic
6. **Authorization** - Permission checks
7. **Side effects** - Database calls, external APIs

#### ‚ùå Don't Test

1. **Third-party libraries** - Already tested
2. **Type definitions** - TypeScript handles this
3. **Simple getters/setters** - No business logic
4. **Configuration files** - Static data

### Example Test Coverage

For a service method with this signature:

```typescript
async createPayment(userId: number, data: CreatePaymentDTO): Promise<ApiResponse<PaymentResponseDTO>>
```

Test these scenarios:

```typescript
describe("createPayment", () => {
  it("should create payment successfully");
  it("should return error when user not found");
  it("should return error when post not found");
  it("should return error when user tries to pay for own post");
  it("should handle database error during payment creation");
});
```

---

## Running Tests

### Commands

```bash
# Run all tests
npm test

# Run tests in watch mode
npm run test:watch

# Run tests with coverage
npm run test:coverage

# Run specific test file
npm test -- user.service.test

# Run tests matching pattern
npm test -- --testNamePattern="should create user"

# Update snapshots
npm test -- -u
```

### Package.json Scripts

```json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:verbose": "jest --verbose"
  }
}
```

### Interpreting Coverage Reports

After running `npm run test:coverage`:

```
--------------------------|---------|----------|---------|---------|--------------------
File                      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s
--------------------------|---------|----------|---------|---------|--------------------
All files                 |   58.34 |    52.81 |   35.13 |   58.93 |
 services/                |   80.29 |    57.36 |   89.36 |   80.14 |
  auth.service.ts         |     100 |    78.57 |     100 |     100 | 77-89,144-156
  user.service.ts         |   98.71 |    62.79 |     100 |   98.71 | 302
  payment.service.ts      |     100 |    73.91 |     100 |     100 | 89,100,162-173
--------------------------|---------|----------|---------|---------|--------------------
```

**Reading the report:**

- `% Stmts` - Percentage of statements executed
- `% Branch` - Percentage of conditional branches tested
- `% Funcs` - Percentage of functions called
- `% Lines` - Percentage of lines executed
- `Uncovered Line #s` - Lines not covered (often catch blocks or early returns)

---

## Best Practices

### 1. Test Naming

Use descriptive test names that explain the scenario:

```typescript
// ‚úÖ Good
it("should return error when user not found");
it("should create payment successfully with valid data");
it("should prevent user from paying for their own post");

// ‚ùå Bad
it("works");
it("test payment");
it("error case");
```

### 2. One Assertion Per Concept

Focus each test on one behavior:

```typescript
// ‚úÖ Good - Tests one concept
it("should return user profile with all fields", async () => {
  const result = await userService.getProfile(userId);

  expect(result.success).toBe(true);
  expect(result.data?.id).toBe(mockUser.id);
  expect(result.data?.email).toBe(mockUser.email);
  expect(result.data?.fullName).toBe(mockUser.fullName);
});

// ‚úÖ Good - Separate tests for different concepts
it("should return error when user not found", async () => {
  const result = await userService.getProfile(999);
  expect(result.success).toBe(false);
});

// ‚ùå Bad - Testing multiple unrelated behaviors
it("should handle all cases", async () => {
  // Tests both success and failure in one test
});
```

### 3. Isolate Tests

Each test should be independent:

```typescript
// ‚úÖ Good - Reset mocks in beforeEach
beforeEach(() => {
  jest.clearAllMocks();
  service = new ServiceName();
  mockData = createMockUser();
});

// ‚ùå Bad - Tests depend on execution order
let sharedState;
it("first test", () => {
  sharedState = "value";
});
it("second test", () => {
  expect(sharedState).toBe("value"); // Depends on first test
});
```

### 4. Test Edge Cases

Don't just test the happy path:

```typescript
describe("updateProfile", () => {
  it("should update profile successfully");
  it("should return error when user not found");
  it("should return error when email already exists");
  it("should handle partial updates");
  it("should validate email format");
  it("should handle database errors");
  it("should not update password through this method");
});
```

### 5. Use Descriptive Variables

```typescript
// ‚úÖ Good
const validUserData = createMockUser();
const invalidEmail = "not-an-email";
const existingUser = createMockUser({ email: "existing@example.com" });

// ‚ùå Bad
const data1 = createMockUser();
const x = "test";
const u = createMockUser();
```

### 6. Keep Tests DRY (Don't Repeat Yourself)

```typescript
// ‚úÖ Good - Extract common setup
const setupMockRepositories = () => {
  (userRepository.findById as MockedFunction).mockResolvedValue(mockUser);
  (postRepository.findById as MockedFunction).mockResolvedValue(mockPost);
};

describe("createPayment", () => {
  beforeEach(() => {
    setupMockRepositories();
  });

  // Tests here
});

// ‚ùå Bad - Duplicate setup in every test
it("test 1", () => {
  (userRepository.findById as MockedFunction).mockResolvedValue(mockUser);
  (postRepository.findById as MockedFunction).mockResolvedValue(mockPost);
  // Test logic
});

it("test 2", () => {
  (userRepository.findById as MockedFunction).mockResolvedValue(mockUser);
  (postRepository.findById as MockedFunction).mockResolvedValue(mockPost);
  // Test logic
});
```

### 7. Test Error Messages

Verify error messages and codes:

```typescript
it("should return descriptive error when payment not found", async () => {
  (paymentRepository.findById as MockedFunction).mockResolvedValue(null);

  const result = await paymentService.getPaymentById(999);

  expect(result.success).toBe(false);
  expect(result.error?.code).toBe(ErrorCode.RESOURCE_NOT_FOUND);
  expect(result.error?.statusCode).toBe(404);
  expect(result.error?.message).toBe("Payment not found");
});
```

### 8. Avoid Testing Implementation Details

Test behavior, not implementation:

```typescript
// ‚úÖ Good - Tests behavior
it("should hash password before storing", async () => {
  const password = "Test123!";
  const result = await authService.register({ password });

  expect(result.success).toBe(true);
  // Verify password is hashed (not plaintext)
  expect(result.data?.password).not.toBe(password);
});

// ‚ùå Bad - Tests implementation
it("should call bcrypt.hash with correct parameters", async () => {
  // Too tightly coupled to implementation
});
```

---

## Examples

### Example 1: Service Test (Complete)

```typescript
import { describe, it, expect, beforeEach, jest } from "@jest/globals";
import { UserService } from "../../../services/user.service";
import { userRepository, postRepository } from "../../../dal/repositories";
import { createMockUser } from "../../helpers/test-data";
import { ErrorCode } from "../../../types/common/api-response.types";

type MockedFunction = jest.MockedFunction<any>;

jest.mock("../../../dal/repositories", () => ({
  userRepository: {
    findById: jest.fn<any>(),
    update: jest.fn<any>(),
  },
  postRepository: {
    countUserPosts: jest.fn<any>(),
  },
  categoryRepository: {},
  paymentRepository: {},
}));

describe("UserService", () => {
  let userService: UserService;
  let mockUser: any;

  beforeEach(() => {
    jest.clearAllMocks();
    userService = new UserService();
    mockUser = createMockUser();
  });

  describe("getProfile", () => {
    it("should return user profile successfully", async () => {
      // Arrange
      (userRepository.findById as MockedFunction).mockResolvedValue(mockUser);

      // Act
      const result = await userService.getProfile(mockUser.id);

      // Assert
      expect(result.success).toBe(true);
      expect(result.data).toBeDefined();
      expect(result.data?.id).toBe(mockUser.id);
      expect(result.data?.email).toBe(mockUser.email);
      expect(userRepository.findById).toHaveBeenCalledWith(mockUser.id);
    });

    it("should return error when user not found", async () => {
      // Arrange
      (userRepository.findById as MockedFunction).mockResolvedValue(null);

      // Act
      const result = await userService.getProfile(999);

      // Assert
      expect(result.success).toBe(false);
      expect(result.error?.code).toBe(ErrorCode.RESOURCE_NOT_FOUND);
      expect(result.error?.statusCode).toBe(404);
      expect(result.error?.message).toBe("User not found");
    });

    it("should handle database errors", async () => {
      // Arrange
      (userRepository.findById as MockedFunction).mockRejectedValue(
        new Error("Database connection failed")
      );

      // Act
      const result = await userService.getProfile(mockUser.id);

      // Assert
      expect(result.success).toBe(false);
      expect(result.error?.code).toBe(ErrorCode.INTERNAL_ERROR);
      expect(result.error?.statusCode).toBe(500);
    });
  });

  describe("updateProfile", () => {
    it("should update profile successfully", async () => {
      // Arrange
      const updateData = {
        fullName: "New Name",
        location: "New Location",
      };
      const updatedUser = { ...mockUser, ...updateData };

      (userRepository.findById as MockedFunction).mockResolvedValue(mockUser);
      (userRepository.update as MockedFunction).mockResolvedValue(updatedUser);

      // Act
      const result = await userService.updateProfile(mockUser.id, updateData);

      // Assert
      expect(result.success).toBe(true);
      expect(result.data?.fullName).toBe(updateData.fullName);
      expect(result.data?.location).toBe(updateData.location);
      expect(userRepository.update).toHaveBeenCalledWith(
        mockUser.id,
        expect.objectContaining(updateData)
      );
    });
  });
});
```

### Example 2: Utility Test

```typescript
import { describe, it, expect } from "@jest/globals";
import { PasswordUtil } from "../../../utils/password.util";

describe("PasswordUtil", () => {
  describe("hash", () => {
    it("should hash password successfully", async () => {
      const password = "Test123!";
      const hash = await PasswordUtil.hash(password);

      expect(hash).toBeDefined();
      expect(hash).not.toBe(password);
      expect(hash.length).toBeGreaterThan(50);
    });

    it("should generate different hashes for same password", async () => {
      const password = "Test123!";
      const hash1 = await PasswordUtil.hash(password);
      const hash2 = await PasswordUtil.hash(password);

      expect(hash1).not.toBe(hash2);
    });
  });

  describe("verify", () => {
    it("should verify correct password", async () => {
      const password = "Test123!";
      const hash = await PasswordUtil.hash(password);
      const isValid = await PasswordUtil.verify(password, hash);

      expect(isValid).toBe(true);
    });

    it("should reject incorrect password", async () => {
      const password = "Test123!";
      const hash = await PasswordUtil.hash(password);
      const isValid = await PasswordUtil.verify("WrongPass123!", hash);

      expect(isValid).toBe(false);
    });
  });

  describe("validateStrength", () => {
    it("should accept strong password", () => {
      const result = PasswordUtil.validateStrength("Test123!");
      expect(result.isValid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    it("should reject password without uppercase", () => {
      const result = PasswordUtil.validateStrength("test123!");
      expect(result.isValid).toBe(false);
      expect(result.errors).toContain(
        "Password must contain at least one uppercase letter"
      );
    });

    it("should reject short password", () => {
      const result = PasswordUtil.validateStrength("Test1!");
      expect(result.isValid).toBe(false);
      expect(result.errors).toContain(
        "Password must be at least 8 characters long"
      );
    });
  });
});
```

### Example 3: Testing with Multiple Repositories

```typescript
import { describe, it, expect, beforeEach, jest } from "@jest/globals";
import { PaymentService } from "../../../services/payment.service";
import {
  paymentRepository,
  userRepository,
  postRepository,
} from "../../../dal/repositories";
import {
  createMockUser,
  createMockPost,
  createMockPayment,
} from "../../helpers/test-data";

type MockedFunction = jest.MockedFunction<any>;

jest.mock("../../../dal/repositories", () => ({
  paymentRepository: {
    findById: jest.fn<any>(),
    createPayment: jest.fn<any>(),
  },
  userRepository: {
    findById: jest.fn<any>(),
  },
  postRepository: {
    findById: jest.fn<any>(),
  },
  categoryRepository: {},
  likeRepository: {},
}));

describe("PaymentService", () => {
  let paymentService: PaymentService;
  let mockUser: any;
  let mockPost: any;
  let mockPayment: any;

  beforeEach(() => {
    jest.clearAllMocks();
    paymentService = new PaymentService();
    mockUser = createMockUser();
    mockPost = createMockPost(999, 1); // Different user owns post
    mockPayment = createMockPayment(mockUser.id, mockPost.id);
  });

  describe("createPayment", () => {
    it("should create payment successfully", async () => {
      // Arrange
      const createData = {
        postId: mockPost.id,
        pricingTierId: 1,
        paymentMethod: "MobileMoney" as any,
      };

      (userRepository.findById as MockedFunction).mockResolvedValue(mockUser);
      (postRepository.findById as MockedFunction).mockResolvedValue(mockPost);
      (paymentRepository.createPayment as MockedFunction).mockResolvedValue(
        mockPayment
      );

      // Act
      const result = await paymentService.createPayment(
        mockUser.id,
        createData
      );

      // Assert
      expect(result.success).toBe(true);
      expect(result.data?.userId).toBe(mockUser.id);
      expect(result.data?.postId).toBe(mockPost.id);
      expect(paymentRepository.createPayment).toHaveBeenCalledWith({
        postId: createData.postId,
        userId: mockUser.id,
        amount: Number(mockPost.price),
        currency: "UGX",
        paymentMethod: createData.paymentMethod,
      });
    });

    it("should prevent user from paying for own post", async () => {
      // Arrange
      const ownPost = createMockPost(mockUser.id, 1);

      (userRepository.findById as MockedFunction).mockResolvedValue(mockUser);
      (postRepository.findById as MockedFunction).mockResolvedValue(ownPost);

      // Act
      const result = await paymentService.createPayment(mockUser.id, {
        postId: ownPost.id,
        pricingTierId: 1,
        paymentMethod: "Card" as any,
      });

      // Assert
      expect(result.success).toBe(false);
      expect(result.error?.code).toBe(ErrorCode.BAD_REQUEST);
      expect(result.error?.message).toBe(
        "You cannot make payment for your own post"
      );
    });
  });
});
```

---

## Common Pitfalls

### 1. Forgetting to Clear Mocks

```typescript
// ‚ùå Bad - Mocks persist between tests
describe("Service", () => {
  it("test 1", () => {
    (repo.method as MockedFunction).mockResolvedValue(data);
  });

  it("test 2", () => {
    // Mock from test 1 still active!
  });
});

// ‚úÖ Good
describe("Service", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  // Tests here
});
```

### 2. Not Including All Repositories in Mock

```typescript
// ‚ùå Bad - Missing repositories cause errors
jest.mock("../../../dal/repositories", () => ({
  userRepository: {
    findById: jest.fn<any>(),
  },
  // Missing other repositories!
}));

// ‚úÖ Good - Include all repositories
jest.mock("../../../dal/repositories", () => ({
  userRepository: {
    findById: jest.fn<any>(),
  },
  postRepository: {},
  categoryRepository: {},
  paymentRepository: {},
  likeRepository: {},
  viewRepository: {},
}));
```

### 3. Using jest.Mock Instead of MockedFunction

```typescript
// ‚ùå Bad - Type errors
(repository.method as jest.Mock).mockResolvedValue(data);

// ‚úÖ Good - Proper typing
type MockedFunction = jest.MockedFunction<any>;
(repository.method as MockedFunction).mockResolvedValue(data);
```

### 4. Not Testing All Error Paths

```typescript
// ‚ùå Bad - Only tests success
describe("createUser", () => {
  it("should create user successfully");
});

// ‚úÖ Good - Tests all paths
describe("createUser", () => {
  it("should create user successfully");
  it("should return error when email exists");
  it("should return error when validation fails");
  it("should handle database errors");
});
```

---

## Troubleshooting

### Issue: "Cannot find module '@jest/globals'"

**Solution:** Install dependencies

```bash
npm install --save-dev @jest/globals @types/jest
```

### Issue: "Type 'Mock' is not assignable to type 'never'"

**Solution:** Use MockedFunction type

```typescript
type MockedFunction = jest.MockedFunction<any>;
(repository.method as MockedFunction).mockResolvedValue(data);
```

### Issue: Tests fail with "Module not mocked"

**Solution:** Ensure jest.mock is called before imports and includes all repositories

```typescript
jest.mock("../../../dal/repositories", () => ({
  // All repositories here
}));
```

### Issue: Coverage not reaching threshold

**Solution:** Check uncovered lines in report and add tests

```bash
npm run test:coverage
# Look at "Uncovered Line #s" column
```

---

## Additional Resources

- [Jest Documentation](https://jestjs.io/docs/getting-started)
- [ts-jest Documentation](https://kulshekhar.github.io/ts-jest/)
- [@faker-js/faker Documentation](https://fakerjs.dev/guide/)
- [Testing Best Practices](https://testingjavascript.com/)

---

## Checklist for New Tests

Before submitting your test file:

- [ ] Test file named with `.test.ts` extension
- [ ] All imports from `@jest/globals`
- [ ] `MockedFunction` type defined
- [ ] All repositories mocked (including empty objects for unused ones)
- [ ] `beforeEach` clears all mocks
- [ ] Test data uses helpers from `test-data.ts`
- [ ] Tests follow AAA pattern (Arrange-Act-Assert)
- [ ] All success paths tested
- [ ] All error paths tested
- [ ] Edge cases covered
- [ ] Descriptive test names
- [ ] Mock calls verified with `expect(...).toHaveBeenCalledWith(...)`
- [ ] Coverage meets 80% threshold
- [ ] All tests pass: `npm test`

---

**Happy Testing! üéâ**
