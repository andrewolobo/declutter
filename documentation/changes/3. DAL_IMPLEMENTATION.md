# Data Access Layer (DAL) Implementation

## Overview

The Data Access Layer has been successfully implemented for the DEC_L application using the Repository pattern with Prisma ORM. This provides a clean separation between business logic and database operations.

## Implementation Date

December 11, 2025

## Architecture

```

   API Layer           (Express Controllers & Routes)
   (Future)



   Service Layer       (Business Logic - Future)
   (Future)



   DAL Layer            IMPLEMENTED
   (Repositories)



   Prisma ORM           CONFIGURED



   Database            (SQL Server)
   (Azure SQL)

```

## Files Created

### Core DAL Files

1. **src/dal/prisma.client.ts**

   - Prisma Client singleton
   - Ensures single database connection
   - Automatic cleanup on shutdown

2. **src/dal/repositories/base.repository.ts**
   - Abstract base class for all repositories
   - Provides common CRUD operations
   - Transaction support
   - Generic type support

### Repository Implementations

3. **src/dal/repositories/user.repository.ts**

   - User authentication and management
   - OAuth user creation
   - Profile updates
   - User activation/deactivation

4. **src/dal/repositories/post.repository.ts**

   - Post feed retrieval
   - Post CRUD operations
   - Search functionality
   - Admin approval/rejection
   - Scheduling support
   - View/like count tracking

5. **src/dal/repositories/like.repository.ts**

   - Like/unlike posts
   - Check user like status
   - Get post likes with user details
   - User's liked posts retrieval

6. **src/dal/repositories/category.repository.ts**

   - Category management
   - Category listing with post counts
   - Category search

7. **src/dal/repositories/payment.repository.ts**

   - Payment record creation
   - Payment confirmation
   - Transaction reference lookup
   - Pending payments retrieval

8. **src/dal/repositories/view.repository.ts**

   - View tracking
   - Unique view detection (24-hour window)
   - Trending posts calculation
   - View analytics

9. **src/dal/repositories/index.ts**
   - Exports all repositories
   - Provides singleton instances
   - Central import point

### Supporting Files

10. **src/dal/README.md**

    - Comprehensive DAL documentation
    - Usage examples for each repository
    - Best practices guide

11. **src/test-dal.ts**

    - DAL testing and verification
    - Repository initialization tests

12. **tsconfig.json**
    - TypeScript configuration
    - ES2020 target
    - Strict type checking enabled

## Repository Features

### BaseRepository (Inherited by all repositories)

```typescript
class BaseRepository<T> {
  findById(id: number, include?: any): Promise<T | null>;
  findAll(options?: FindOptions): Promise<T[]>;
  findOne(where: any, include?: any): Promise<T | null>;
  create(data: any): Promise<T>;
  update(id: number, data: any): Promise<T>;
  delete(id: number): Promise<T>;
  count(where?: any): Promise<number>;
  exists(where: any): Promise<boolean>;
  transaction<R>(callback): Promise<R>;
}
```

### UserRepository

**Key Methods:**

- `findByEmail(email)` - Email lookup for authentication
- `findByPhoneNumber(phoneNumber)` - Phone number search
- `findByOAuth(provider, providerId)` - OAuth provider lookup
- `createOAuthUser(data)` - Register OAuth user
- `createPasswordUser(data)` - Register email/password user
- `updateProfile(userId, data)` - Update user details
- `getUserWithPosts(userId)` - User with all posts
- `activate(userId)` / `deactivate(userId)` - Account management

### PostRepository

**Key Methods:**

- `getFeed(options)` - Paginated feed of active posts
- `getPostDetails(postId)` - Single post with full details
- `createPost(data)` - Create post with images
- `updatePost(postId, data)` - Update post details
- `getUserPosts(userId, status?)` - User's posts
- `getPendingPosts()` - Posts awaiting approval
- `approvePost(postId)` - Admin approval
- `rejectPost(postId)` - Admin rejection
- `schedulePost(postId, time)` - Schedule for later
- `searchPosts(query, limit)` - Full-text search
- `incrementViewCount(postId)` - Track views
- `updateLikeCount(postId, increment)` - Track likes

### LikeRepository

**Key Methods:**

- `likePost(userId, postId)` - Add like
- `unlikePost(userId, postId)` - Remove like
- `hasUserLiked(userId, postId)` - Check like status
- `getPostLikes(postId)` - Get all likes for post
- `getUserLikedPosts(userId)` - Posts liked by user
- `getLikeCount(postId)` - Total like count

### CategoryRepository

**Key Methods:**

- `getAllCategories()` - All categories
- `getCategoriesWithCount()` - Categories with post counts
- `findByName(name)` - Search by name
- `createCategory(data)` - Add new category

### PostImageRepository

**Purpose:** Dedicated repository for post image management

**Key Methods** (7 total):

1. `addImage(data: { postId, imageUrl, displayOrder })` - Add image to post
2. `getByPostId(postId)` - Retrieve all images for a post (ordered by displayOrder)
3. `updateDisplayOrder(imageId, displayOrder)` - Update single image order
4. `deleteImage(imageId)` - Delete single image
5. `deleteByPostId(postId)` - Delete all images for a post (cascade delete)
6. `countByPostId(postId)` - Count images for a post
7. `reorderImages(images: Array<{ id, displayOrder }>)` - Batch reorder images

**Business Rules:**

- Maximum 10 images per post (enforced by PostService)
- Display order starts at 0
- Cascade delete when parent post is deleted
- Images ordered by displayOrder for gallery display

**Usage:**

```typescript
// Add image during post creation
await postImageRepository.addImage({
  postId: 123,
  imageUrl: "https://cdn.example.com/image.jpg",
  displayOrder: 0,
});

// Reorder images
await postImageRepository.reorderImages([
  { id: 1, displayOrder: 2 },
  { id: 2, displayOrder: 0 },
  { id: 3, displayOrder: 1 },
]);

// Cascade delete all images
await postImageRepository.deleteByPostId(123);
```

### PaymentRepository

**Key Methods:**

- `createPayment(data)` - Record payment
- `confirmPayment(paymentId)` - Mark as confirmed
- `failPayment(paymentId)` - Mark as failed
- `findByTransactionRef(reference)` - Lookup by transaction
- `getPostPayments(postId)` - Payments for post
- `getUserPayments(userId)` - User's payment history
- `getPendingPayments()` - Unconfirmed payments

### ViewRepository

**Key Methods:**

- `recordView(data)` - Track post view
- `isUniqueView(postId, userId, ip, session)` - Detect unique views
- `updateViewDuration(viewId, duration)` - Track engagement
- `getPostViewCount(postId)` - Total views
- `getPostUniqueViewCount(postId)` - Unique views
- `getTrendingPosts(limit, hours)` - Most viewed posts

## Type Safety

All repositories are fully type-safe using Prisma's generated types:

```typescript
import { User, Post, Like, Category } from "@prisma/client";

// Automatic type inference
const user: User = await userRepository.findById(1);
const posts: Post[] = await postRepository.getFeed({ limit: 10 });
```

## Transaction Support

Complex operations can use transactions:

```typescript
await userRepository.transaction(async (tx) => {
  const user = await tx.user.create({ data: userData });
  const post = await tx.post.create({
    data: { ...postData, userId: user.id },
  });
  return { user, post };
});
```

## Usage Examples

### Authentication Flow

```typescript
// Check if user exists by email
let user = await userRepository.findByEmail(email);

if (!user) {
  // Create new OAuth user
  user = await userRepository.createOAuthUser({
    email,
    phoneNumber,
    fullName,
    oauthProvider: "google",
    oauthProviderId: googleId,
  });
}
```

### Post Feed

```typescript
// Get feed with pagination
const posts = await postRepository.getFeed({
  limit: 20,
  offset: page * 20,
  categoryId: selectedCategory,
});

// Check which posts user has liked
const postsWithLikeStatus = await Promise.all(
  posts.map(async (post) => ({
    ...post,
    isLiked: await likeRepository.hasUserLiked(userId, post.id),
  }))
);
```

### Post Creation

```typescript
const post = await postRepository.createPost({
  userId,
  title: "Used Laptop",
  categoryId: 1,
  description: "Dell Laptop in excellent condition",
  price: 500000,
  location: "Kampala",
  contactNumber: "+256123456789",
  images: [
    { imageUrl: "https://cdn.../image1.jpg", displayOrder: 0 },
    { imageUrl: "https://cdn.../image2.jpg", displayOrder: 1 },
  ],
});
```

### Like Toggle

```typescript
const hasLiked = await likeRepository.hasUserLiked(userId, postId);

if (hasLiked) {
  await likeRepository.unlikePost(userId, postId);
  await postRepository.updateLikeCount(postId, false);
} else {
  await likeRepository.likePost(userId, postId);
  await postRepository.updateLikeCount(postId, true);
}
```

### Payment Processing

```typescript
// Create payment record
const payment = await paymentRepository.createPayment({
  postId,
  userId,
  amount: post.price,
  paymentMethod: "MobileMoney",
  transactionReference: smsTransactionId,
});

// Later, when SMS confirms payment
await paymentRepository.confirmPayment(payment.id);
await postRepository.approvePost(postId);
```

## Testing

Run the test file to verify DAL setup:

```bash
npx ts-node src/test-dal.ts
```

## Dependencies Installed

- `@prisma/client@^6.19.1` - Prisma ORM client
- `prisma@^6.19.1` - Prisma CLI (dev dependency)
- `typescript@latest` - TypeScript compiler (dev)
- `@types/node@latest` - Node.js type definitions (dev)
- `ts-node@latest` - TypeScript execution (dev)

## Next Steps

### Phase 2: Service Layer

Create business logic layer that uses these repositories:

1. **AuthService**

   - User registration
   - OAuth authentication
   - JWT token management
   - Phone verification

2. **PostService**

   - Post creation workflow
   - Feed retrieval with user context
   - Like/unlike logic
   - Search and filtering

3. **PaymentService**

   - Payment processing
   - SMS parsing
   - Post activation

4. **AnalyticsService**
   - View tracking
   - Trending calculation
   - User analytics

### Phase 3: API Layer

Build Express API controllers and routes:

- `POST /api/auth/register`
- `POST /api/auth/login`
- `GET /api/posts` (feed)
- `GET /api/posts/:id`
- `POST /api/posts`
- `POST /api/posts/:id/like`
- `DELETE /api/posts/:id/like`
- `GET /api/categories`
- `GET /api/users/profile`
- Admin endpoints

## Benefits Achieved

**Separation of Concerns** - Data access isolated from business logic  
 **Type Safety** - Full TypeScript support with Prisma types  
 **Reusability** - Common operations in base repository  
 **Testability** - Easy to mock repositories in tests  
 **Maintainability** - Clear structure and documentation  
 **Performance** - Prisma query optimization  
 **Database Agnostic** - Easy to switch databases  
 **Transaction Support** - ACID compliance when needed

## Conclusion

The Data Access Layer is now fully implemented and ready for use. All repositories are type-safe, well-documented, and follow best practices. The next phase is to build the Service Layer that will use these repositories to implement business logic.
